import usocketimport _threadfrom os import stat, listdirfrom time import sleep_msWEB_FOLDER = '/www'webserv_sock = NoneMIMETYPES = {    "txt"   : "text/plain",    "htm"   : "text/html",    "html"  : "text/html",    "css"   : "text/css",    "csv"   : "text/csv",    "js"    : "application/javascript",    "xml"   : "application/xml",    "xhtml" : "application/xhtml+xml",    "json"  : "application/json",    "zip"   : "application/zip",    "pdf"   : "application/pdf",    "ts"    : "application/typescript",    "woff"  : "font/woff",    "woff2" : "font/woff2",    "ttf"   : "font/ttf",    "otf"   : "font/otf",    "jpg"   : "image/jpeg",    "jpeg"  : "image/jpeg",    "png"   : "image/png",    "gif"   : "image/gif",    "svg"   : "image/svg+xml",    "ico"   : "image/x-icon",    "cur"   : "application/octet-stream",    "tar"   : "application/tar",    "tar.gz": "application/tar+gzip",    "ico"   : "image/x-icon",    "svg"   : "image/svg+xml",    "gz"    : "application/gzip",    "mp3"   : "audio/mpeg",    "wav"   : "audio/wav",    "ogg"   : "audio/ogg"}def _fileExists(path):    try:        stat(path)        return True    except:        return Falsedef get_mime_type(filename):    _, ext = filename.rsplit(".", 1)    return MIMETYPES.get(ext, "application/octet-stream")def read_in_chunks(file_object, chunk_size=1024):    while True:        data = file_object.read(chunk_size)        if not data:            break        yield datadef set_virtual_joystick(client,msg):    global L_v_joyX    global L_v_joyY    global R_v_joyX    global R_v_joyY    global L_v_press    global R_v_press        R_v_joyX = msg.split(";")[1]    R_v_joyY = msg.split(";")[2]    R_v_press = msg.split(";")[3]    L_v_joyX = msg.split(";")[4]    L_v_joyY = msg.split(";")[5]    L_v_press = msg.split(";")[6]        #print("X:" + R_v_joyX + "  Y:" + R_v_joyY)    try:        client.write("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\nOK".encode("utf-8"))    except OSError as e:        print("OSError:", e)def send_virtual_display(client,msg):    global buffer    try:        client.write("HTTP/1.1 200 OK\r\nContent-Type: application/octet-stream\r\n\r\n".encode("utf-8"))        client.write(buffer)    except OSError as e:        print("OSError:", e)# Vraci seznam souboru v adresari mojeblokydef send_new_block_list(client,msg):    try:        files = os.listdir('/moje_bloky')        files_without_extension = [f.split('.', 1)[0] if '.' in f else f for f in files]        files_list = ';'.join(files_without_extension)        client.write("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n".encode("utf-8"))        client.write(files_list.encode("utf-8"))    except OSError as e:        print("OSError:", e)def serve_file(client, path):    try:        #print(path)                if path.startswith("/*"):            if path.startswith("/*JOY;"):                set_virtual_joystick(client,path)                return                        if path.startswith("/*FB"):                send_virtual_display(client,path)                return                        if path.startswith("/*NEW_BLOCKS"):                send_new_block_list(client,path)                return                        if path.startswith("/*GET_FILE"):                file_path = path.replace("/*GET_FILE", "")                    else:            if path == "/":                path = "/index.html"            file_path = WEB_FOLDER + path        mime_type = get_mime_type(path)        filestatus = 0 # 0=Not found  1=Found  2=found in GZip        if _fileExists(file_path + '.gz'):            filestatus = 2            file_path += '.gz'        elif _fileExists(file_path):            filestatus = 1                if filestatus > 0:            with open(file_path, 'rb') as file:                client.write(b'HTTP/1.1 200 OK\r\n')                client.write(b"Content-Type: " + mime_type.encode() + b"\r\n")                if filestatus == 2:                    client.write(b'Content-Encoding: gzip\r\n')                client.write(b'\r\n')                for piece in read_in_chunks(file):                    client.write(piece)        else:            client.write(b"HTTP/1.0 404 Not Found\r\n\r\nFile not found.")    except OSError as e:        print("OSError:", e)        client.write(b"HTTP/1.0 500 Internal Server Error\r\n\r\nInternal error.")    except Exception as e:        print("Exception:", e)        client.write(b"HTTP/1.0 500 Internal Server Error\r\n\r\nInternal error.")def client_handler(client):    try:        request = client.recv(1024)        if request:            _, path, _ = request.decode("utf-8").split(" ", 2)            serve_file(client, path)    except Exception as e:        #print("Client handler exception:", e)        time.sleep_ms(0)    finally:        client.close()def web_thread():    while True:        try:            cl, addr = webserv_sock.accept()            #print(addr)            cl.settimeout(2) # time in seconds            client_handler(cl)        except Exception as ex :            #print("Web thread exception:", ex)            time.sleep_ms(0)def webserver_stop():    global webserv_sock    if webserv_sock:        webserv_sock.close()addr = usocket.getaddrinfo('0.0.0.0', 80)[0][-1]webserv_sock = usocket.socket()webserv_sock.setsockopt(usocket.SOL_SOCKET, usocket.SO_REUSEADDR, 1)webserv_sock.bind(addr)webserv_sock.listen(5)_thread.start_new_thread(web_thread, ())for interface in [network.AP_IF, network.STA_IF]:        wlan = network.WLAN(interface)        if not wlan.active():            continue        ifconfig = wlan.ifconfig()        print("Web server spusten na adrese {}:{}".format(ifconfig[0], 80))